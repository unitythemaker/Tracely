// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type EventType string

const (
	EventTypeMETRICCREATED   EventType = "METRIC_CREATED"
	EventTypeINCIDENTCREATED EventType = "INCIDENT_CREATED"
	EventTypeINCIDENTUPDATED EventType = "INCIDENT_UPDATED"
)

func (e *EventType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EventType(s)
	case string:
		*e = EventType(s)
	default:
		return fmt.Errorf("unsupported scan type for EventType: %T", src)
	}
	return nil
}

type NullEventType struct {
	EventType EventType `json:"event_type"`
	Valid     bool      `json:"valid"` // Valid is true if EventType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEventType) Scan(value interface{}) error {
	if value == nil {
		ns.EventType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EventType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEventType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EventType), nil
}

type IncidentEventType string

const (
	IncidentEventTypeCREATED         IncidentEventType = "CREATED"
	IncidentEventTypeSTATUSCHANGED   IncidentEventType = "STATUS_CHANGED"
	IncidentEventTypeCOMMENTADDED    IncidentEventType = "COMMENT_ADDED"
	IncidentEventTypeASSIGNED        IncidentEventType = "ASSIGNED"
	IncidentEventTypeSEVERITYCHANGED IncidentEventType = "SEVERITY_CHANGED"
)

func (e *IncidentEventType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = IncidentEventType(s)
	case string:
		*e = IncidentEventType(s)
	default:
		return fmt.Errorf("unsupported scan type for IncidentEventType: %T", src)
	}
	return nil
}

type NullIncidentEventType struct {
	IncidentEventType IncidentEventType `json:"incident_event_type"`
	Valid             bool              `json:"valid"` // Valid is true if IncidentEventType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullIncidentEventType) Scan(value interface{}) error {
	if value == nil {
		ns.IncidentEventType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.IncidentEventType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullIncidentEventType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.IncidentEventType), nil
}

type IncidentSeverity string

const (
	IncidentSeverityCRITICAL IncidentSeverity = "CRITICAL"
	IncidentSeverityHIGH     IncidentSeverity = "HIGH"
	IncidentSeverityMEDIUM   IncidentSeverity = "MEDIUM"
	IncidentSeverityLOW      IncidentSeverity = "LOW"
)

func (e *IncidentSeverity) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = IncidentSeverity(s)
	case string:
		*e = IncidentSeverity(s)
	default:
		return fmt.Errorf("unsupported scan type for IncidentSeverity: %T", src)
	}
	return nil
}

type NullIncidentSeverity struct {
	IncidentSeverity IncidentSeverity `json:"incident_severity"`
	Valid            bool             `json:"valid"` // Valid is true if IncidentSeverity is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullIncidentSeverity) Scan(value interface{}) error {
	if value == nil {
		ns.IncidentSeverity, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.IncidentSeverity.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullIncidentSeverity) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.IncidentSeverity), nil
}

type IncidentStatus string

const (
	IncidentStatusOPEN       IncidentStatus = "OPEN"
	IncidentStatusINPROGRESS IncidentStatus = "IN_PROGRESS"
	IncidentStatusCLOSED     IncidentStatus = "CLOSED"
)

func (e *IncidentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = IncidentStatus(s)
	case string:
		*e = IncidentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for IncidentStatus: %T", src)
	}
	return nil
}

type NullIncidentStatus struct {
	IncidentStatus IncidentStatus `json:"incident_status"`
	Valid          bool           `json:"valid"` // Valid is true if IncidentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullIncidentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.IncidentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.IncidentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullIncidentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.IncidentStatus), nil
}

type MetricType string

const (
	MetricTypeLATENCYMS   MetricType = "LATENCY_MS"
	MetricTypePACKETLOSS  MetricType = "PACKET_LOSS"
	MetricTypeERRORRATE   MetricType = "ERROR_RATE"
	MetricTypeBUFFERRATIO MetricType = "BUFFER_RATIO"
)

func (e *MetricType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MetricType(s)
	case string:
		*e = MetricType(s)
	default:
		return fmt.Errorf("unsupported scan type for MetricType: %T", src)
	}
	return nil
}

type NullMetricType struct {
	MetricType MetricType `json:"metric_type"`
	Valid      bool       `json:"valid"` // Valid is true if MetricType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMetricType) Scan(value interface{}) error {
	if value == nil {
		ns.MetricType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MetricType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMetricType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MetricType), nil
}

type RuleAction string

const (
	RuleActionOPENINCIDENT RuleAction = "OPEN_INCIDENT"
	RuleActionTHROTTLE     RuleAction = "THROTTLE"
	RuleActionWEBHOOK      RuleAction = "WEBHOOK"
)

func (e *RuleAction) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RuleAction(s)
	case string:
		*e = RuleAction(s)
	default:
		return fmt.Errorf("unsupported scan type for RuleAction: %T", src)
	}
	return nil
}

type NullRuleAction struct {
	RuleAction RuleAction `json:"rule_action"`
	Valid      bool       `json:"valid"` // Valid is true if RuleAction is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRuleAction) Scan(value interface{}) error {
	if value == nil {
		ns.RuleAction, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RuleAction.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRuleAction) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RuleAction), nil
}

type RuleOperator string

const (
	RuleOperatorValue0 RuleOperator = ">"
	RuleOperatorValue1 RuleOperator = ">="
	RuleOperatorValue2 RuleOperator = "<"
	RuleOperatorValue3 RuleOperator = "<="
	RuleOperatorValue4 RuleOperator = "=="
	RuleOperatorValue5 RuleOperator = "!="
)

func (e *RuleOperator) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RuleOperator(s)
	case string:
		*e = RuleOperator(s)
	default:
		return fmt.Errorf("unsupported scan type for RuleOperator: %T", src)
	}
	return nil
}

type NullRuleOperator struct {
	RuleOperator RuleOperator `json:"rule_operator"`
	Valid        bool         `json:"valid"` // Valid is true if RuleOperator is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRuleOperator) Scan(value interface{}) error {
	if value == nil {
		ns.RuleOperator, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RuleOperator.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRuleOperator) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RuleOperator), nil
}

type Department struct {
	ID          string    `json:"id"`
	Name        string    `json:"name"`
	Description *string   `json:"description"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

type Incident struct {
	ID           string             `json:"id"`
	ServiceID    string             `json:"service_id"`
	RuleID       string             `json:"rule_id"`
	MetricID     uuid.UUID          `json:"metric_id"`
	Severity     IncidentSeverity   `json:"severity"`
	Status       IncidentStatus     `json:"status"`
	Message      *string            `json:"message"`
	OpenedAt     time.Time          `json:"opened_at"`
	ClosedAt     pgtype.Timestamptz `json:"closed_at"`
	CreatedAt    time.Time          `json:"created_at"`
	UpdatedAt    time.Time          `json:"updated_at"`
	InProgressAt pgtype.Timestamptz `json:"in_progress_at"`
}

type IncidentComment struct {
	ID         uuid.UUID `json:"id"`
	IncidentID string    `json:"incident_id"`
	Author     string    `json:"author"`
	Content    string    `json:"content"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
}

type IncidentEvent struct {
	ID         uuid.UUID         `json:"id"`
	IncidentID string            `json:"incident_id"`
	EventType  IncidentEventType `json:"event_type"`
	Actor      *string           `json:"actor"`
	OldValue   *string           `json:"old_value"`
	NewValue   *string           `json:"new_value"`
	Metadata   []byte            `json:"metadata"`
	CreatedAt  time.Time         `json:"created_at"`
}

type Metric struct {
	ID         uuid.UUID      `json:"id"`
	ServiceID  string         `json:"service_id"`
	MetricType MetricType     `json:"metric_type"`
	Value      pgtype.Numeric `json:"value"`
	RecordedAt time.Time      `json:"recorded_at"`
	CreatedAt  time.Time      `json:"created_at"`
}

type Notification struct {
	ID           string    `json:"id"`
	IncidentID   string    `json:"incident_id"`
	Target       string    `json:"target"`
	Message      string    `json:"message"`
	SentAt       time.Time `json:"sent_at"`
	CreatedAt    time.Time `json:"created_at"`
	IsRead       bool      `json:"is_read"`
	UpdatedAt    time.Time `json:"updated_at"`
	DepartmentID *string   `json:"department_id"`
}

type Outbox struct {
	ID            uuid.UUID `json:"id"`
	EventType     EventType `json:"event_type"`
	AggregateType string    `json:"aggregate_type"`
	AggregateID   string    `json:"aggregate_id"`
	Payload       []byte    `json:"payload"`
	CreatedAt     time.Time `json:"created_at"`
}

type OutboxProcessing struct {
	OutboxID    uuid.UUID `json:"outbox_id"`
	Processor   string    `json:"processor"`
	ProcessedAt time.Time `json:"processed_at"`
}

type QualityRule struct {
	ID           string           `json:"id"`
	MetricType   MetricType       `json:"metric_type"`
	Threshold    pgtype.Numeric   `json:"threshold"`
	Operator     RuleOperator     `json:"operator"`
	Action       RuleAction       `json:"action"`
	Priority     int32            `json:"priority"`
	Severity     IncidentSeverity `json:"severity"`
	IsActive     bool             `json:"is_active"`
	CreatedAt    time.Time        `json:"created_at"`
	UpdatedAt    time.Time        `json:"updated_at"`
	DepartmentID *string          `json:"department_id"`
}

type Service struct {
	ID        string    `json:"id"`
	Name      string    `json:"name"`
	CreatedAt time.Time `json:"created_at"`
}
