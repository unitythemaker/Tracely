// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: metrics.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createMetric = `-- name: CreateMetric :one
INSERT INTO metrics (service_id, metric_type, value, recorded_at)
VALUES ($1, $2, $3, $4)
RETURNING id, service_id, metric_type, value, recorded_at, created_at
`

type CreateMetricParams struct {
	ServiceID  string         `json:"service_id"`
	MetricType MetricType     `json:"metric_type"`
	Value      pgtype.Numeric `json:"value"`
	RecordedAt time.Time      `json:"recorded_at"`
}

func (q *Queries) CreateMetric(ctx context.Context, arg CreateMetricParams) (Metric, error) {
	row := q.db.QueryRow(ctx, createMetric,
		arg.ServiceID,
		arg.MetricType,
		arg.Value,
		arg.RecordedAt,
	)
	var i Metric
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.MetricType,
		&i.Value,
		&i.RecordedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestMetricByServiceAndType = `-- name: GetLatestMetricByServiceAndType :one
SELECT id, service_id, metric_type, value, recorded_at, created_at FROM metrics
WHERE service_id = $1 AND metric_type = $2
ORDER BY recorded_at DESC
LIMIT 1
`

type GetLatestMetricByServiceAndTypeParams struct {
	ServiceID  string     `json:"service_id"`
	MetricType MetricType `json:"metric_type"`
}

func (q *Queries) GetLatestMetricByServiceAndType(ctx context.Context, arg GetLatestMetricByServiceAndTypeParams) (Metric, error) {
	row := q.db.QueryRow(ctx, getLatestMetricByServiceAndType, arg.ServiceID, arg.MetricType)
	var i Metric
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.MetricType,
		&i.Value,
		&i.RecordedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getMetric = `-- name: GetMetric :one
SELECT id, service_id, metric_type, value, recorded_at, created_at FROM metrics WHERE id = $1
`

func (q *Queries) GetMetric(ctx context.Context, id uuid.UUID) (Metric, error) {
	row := q.db.QueryRow(ctx, getMetric, id)
	var i Metric
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.MetricType,
		&i.Value,
		&i.RecordedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listMetrics = `-- name: ListMetrics :many
SELECT id, service_id, metric_type, value, recorded_at, created_at FROM metrics
ORDER BY recorded_at DESC
LIMIT $1 OFFSET $2
`

type ListMetricsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListMetrics(ctx context.Context, arg ListMetricsParams) ([]Metric, error) {
	rows, err := q.db.Query(ctx, listMetrics, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Metric{}
	for rows.Next() {
		var i Metric
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.MetricType,
			&i.Value,
			&i.RecordedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMetricsByService = `-- name: ListMetricsByService :many
SELECT id, service_id, metric_type, value, recorded_at, created_at FROM metrics
WHERE service_id = $1
ORDER BY recorded_at DESC
LIMIT $2 OFFSET $3
`

type ListMetricsByServiceParams struct {
	ServiceID string `json:"service_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) ListMetricsByService(ctx context.Context, arg ListMetricsByServiceParams) ([]Metric, error) {
	rows, err := q.db.Query(ctx, listMetricsByService, arg.ServiceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Metric{}
	for rows.Next() {
		var i Metric
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.MetricType,
			&i.Value,
			&i.RecordedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMetricsByServiceAndType = `-- name: ListMetricsByServiceAndType :many
SELECT id, service_id, metric_type, value, recorded_at, created_at FROM metrics
WHERE service_id = $1 AND metric_type = $2
ORDER BY recorded_at DESC
LIMIT $3 OFFSET $4
`

type ListMetricsByServiceAndTypeParams struct {
	ServiceID  string     `json:"service_id"`
	MetricType MetricType `json:"metric_type"`
	Limit      int32      `json:"limit"`
	Offset     int32      `json:"offset"`
}

func (q *Queries) ListMetricsByServiceAndType(ctx context.Context, arg ListMetricsByServiceAndTypeParams) ([]Metric, error) {
	rows, err := q.db.Query(ctx, listMetricsByServiceAndType,
		arg.ServiceID,
		arg.MetricType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Metric{}
	for rows.Next() {
		var i Metric
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.MetricType,
			&i.Value,
			&i.RecordedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
